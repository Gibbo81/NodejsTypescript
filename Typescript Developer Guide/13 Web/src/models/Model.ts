//import{Callback} from './Eventing'
import { ApiSync, hasId } from "./ApiSync"


interface IModelAttribute<T extends {}>{
    get<K extends keyof T>(key : K): T[K],
    set(update : T): void,
    getAll() : T
}

interface ISync<T extends {id?: number }>{
    fetch(id: number): Promise<T>,
    save(data: T): Promise<T>
}

interface IEvents{
    //on(eventName: string, callback: Callback) : void,
    on(eventName: string, callback: () => void) : void, //quack rule to avoid importing interface Callback
    trigger(eventName:string) : void
}


export class Model<T extends hasId>{
    constructor(private attribute: IModelAttribute<T>, 
                private sync : ISync<T>,
                private events : IEvents) {}
    
    get<K extends keyof T>(propertyName : K) : T[K]{
        return this.attribute.get(propertyName)
    }   
    set (update : T): void{
        this.attribute.set(update)
        this.events.trigger('change') //to comunicate that the state changed
    }

    //this works legacy
    onold(eventName: string, callback: () => void) : void{
        this.events.on(eventName, callback)
    }
    get on(){ //but because is a SIMPLE PAPERPUSHER we can return back directly the function from the private object
        return this.events.on
    } //but we can have problem with this for this reason we trasform ecents.on into arrow function
    on2 =this.events.on; //same as before but simpler syntax
    
    trigger(eventName:string) : void {
        this.events.trigger(eventName)
    }

    async fetch(): Promise<void> {
        if (this.attribute.get('id')){
            var x = await this.sync.fetch(this.attribute.get("id"))
            this.set(x)
        }
        else
            throw new Error("Missing Id - cannot fetch")
    }
    async save(): Promise<void> {
        var data = await this.sync.save(this.attribute.getAll())
        this.set(data) //to save the id generated by API
        this.trigger('save')   
    }
}